(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{505:function(t,r,o){"use strict";o.r(r);var _=o(4),s=Object(_.a)({},(function(){var t=this,r=t.$createElement,o=t._self._c||r;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("blockquote",[o("p",[t._v("问题思考")])]),t._v(" "),o("ul",[o("li",[o("p",[o("strong",[t._v("操作系统：")]),t._v(" 40ML量程的空杯子，")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("程序：")]),t._v(" 20ML的不同物质组成的水（A程序引用地址：0001，B程序引用地址：0001）")])]),t._v(" "),o("li",[o("p",[t._v("现在需要将A程序装载进操作系统然后运行，然后将B程序装载进操作系统然后运行。")])]),t._v(" "),o("li",[o("p",[t._v("由于A,B程序引用的地址都是同一个，因此想"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("同时运行A,B两个程序是无法实现的！")])])],1)]),t._v(" "),o("li",[o("p",[t._v("而想要将B程序装载进操作系统，需要"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("将A程序先从操作系统中擦除掉")])]),t._v("。")],1)])]),t._v(" "),o("h2",{attrs:{id:"内存管理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("由于A,B程序引用的都是"),o("font",{attrs:{color:"blue"}},[o("strong",[t._v("物理地址")])]),t._v(",导致了操作系统无法同时运行两个程序。")],1)]),t._v(" "),o("li",[o("p",[t._v("为了避免多个进程引用重复物理地址的问题，我们需要将每个进程使用的地址进行"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("隔离")])]),t._v(",给每个进程分配一个"),o("font",{attrs:{color:"blue"}},[o("strong",[t._v("虚拟地址。")])]),t._v("对于进程来说虚拟地址映射到物理地址是透明的，而映射的过程"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("统一由操作系统实现")])]),t._v("，避免"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("物理地址冲突")])])],1)]),t._v(" "),o("li",[o("p",[t._v("虚拟地址映射成物理地址由CPU芯片中的"),o("font",{attrs:{color:"blue"}},[o("strong",[t._v("MMU(Memory Management Unit内存管理单元)")])]),t._v("实现")],1)])]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8xzIH",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8xzIH.md.png",alt:"pp8xzIH.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("blockquote",[o("p",[t._v("操作系统管理虚拟地址和物理地址之间的关系主要有两种方式："),o("font",{attrs:{color:"blue"}},[o("strong",[t._v("内存分段，内存分页")])])],1)]),t._v(" "),o("h3",{attrs:{id:"内存分段"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#内存分段"}},[t._v("#")]),t._v(" 内存分段")]),t._v(" "),o("ul",[o("li",[t._v("程序是由若干个逻辑部分组成的如：代码段、堆段、栈段、数据段。请参考下图")])]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8zPzt",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zPzt.md.png",alt:"pp8zPzt.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("段选择因子")])]),t._v("保存在段寄存器中，其中包含"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("段号")])]),t._v("用于段表的索引，段表中包含了"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("段基地址（起始地址）、段界限，特权信息等")])])],1),t._v(" "),o("li",[t._v("通过段表中的项和"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("段内偏移量(0~段界限值)")])]),t._v("，可求出实际物理地址"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("实际物理地址 = 起始地址+段内偏移量")])])],1)]),t._v(" "),o("blockquote",[o("p",[t._v("内存分段的缺点")])]),t._v(" "),o("ol",[o("li",[o("p",[o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("会造成内存碎片")])])],1)]),t._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("内存交换效率低下")])])],1)])]),t._v(" "),o("h4",{attrs:{id:"内存碎片"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#内存碎片"}},[t._v("#")]),t._v(" 内存碎片")]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8zpid",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zpid.md.png",alt:"pp8zpid.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("ul",[o("li",[t._v("以上图为例，此刻内存空间大小为"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("1GB，")])]),t._v("在B程序退出后释放了128M连续的内存，然而这一片连续的内存空间"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("显然无法装载200M的Z程序。")])]),t._v("而想要让Z程序装载近内存，需要"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("某个大于200M的连续内存空间释放。")])]),t._v("这样就造成了大量的"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("内存碎片")])])],1),t._v(" "),o("li",[t._v("造成内存碎片的主要有两个原因\n"),o("ol",[o("li",[o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("外部内存碎片:")])]),t._v("产生了多个小的不连续的物理内存，导致新的程序无法装载。")],1),t._v(" "),o("li",[o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("内部内存碎片：")])]),t._v("程序的所有内存都装载至物理内存，而有的内存并不是常用的（往往后台的程序我们只会使用那么一个到几个），这样就造成了内存的浪费")],1)])])]),t._v(" "),o("h4",{attrs:{id:"内存交换"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#内存交换"}},[t._v("#")]),t._v(" 内存交换")]),t._v(" "),o("ul",[o("li",[t._v("SWAP：还是解决Z程序无法装载的问题，现在我们在C程序没有使用的时候将其"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("写至硬盘")])]),t._v("，等其使用的时候再将他"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("写回至内存")])]),t._v("，位置紧跟A程序512M后"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("保持连续，")])]),t._v("这样剩余了256M的"),o("strong",[t._v("连续内存空间")]),t._v("让Z程序可以被装载至内存。")],1)]),t._v(" "),o("blockquote",[o("p",[t._v("内存分段效率低的原因")])]),t._v(" "),o("ol",[o("li",[t._v("对于多进程的系统，用分段的方式，非常容易产生内存碎片。导致不得不重新SWAP大量的内存")]),t._v(" "),o("li",[o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("而在SWAP的这个过程，往往交换的是一大段连续的内存空间，占用的IO消耗比较大，速度也会很慢。是一个性能的瓶颈问题。")])])],1)]),t._v(" "),o("h3",{attrs:{id:"内存分页"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#内存分页"}},[t._v("#")]),t._v(" 内存分页")]),t._v(" "),o("blockquote",[o("p",[t._v("为了解决内存分段的性能瓶颈，于是有了内存分页的概念")])]),t._v(" "),o("ul",[o("li",[o("p",[t._v("既然分段需要交换大量的内存空间，那将程序的内存空间更加细粒化进行分页处理")])]),t._v(" "),o("li",[o("p",[t._v("把整个虚拟内存空间，物理内存空间切成一段段内存大小固定的块。这样连续且尺寸固定的块称为"),o("font",{attrs:{color:"blue"}},[o("strong",[t._v("页（Page）")])])],1)]),t._v(" "),o("li",[o("p",[t._v("虚拟空间和物理空间通过"),o("font",{attrs:{color:"blue"}},[o("strong",[t._v("页表")])]),t._v("来进行映射，且"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("页表是常驻内存的。")])]),t._v("在linux操作系统下，一页的大小默认是"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("4KB")])])],1)])]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8zCRI",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zCRI.md.png",alt:"pp8zCRI.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("ul",[o("li",[t._v("进程在页表的映射过程")])]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8z9JA",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8z9JA.md.png",alt:"pp8z9JA.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("blockquote",[o("p",[t._v("分页机制下虚拟地址和物理地址映射的过程")])]),t._v(" "),o("ul",[o("li",[t._v("分页机制下，虚拟地址分为"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("页号(页表的索引值)")])]),t._v("，"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("页偏移量。")])]),t._v("页表中包含"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("虚拟页号，物理页号（物理页的基地址）")])])],1)]),t._v(" "),o("blockquote",[o("p",[t._v("物理地址=物理页号+偏移量")])]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8zFQP",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zFQP.md.png",alt:"pp8zFQP.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("blockquote",[o("p",[t._v("简单的分页存在的缺陷")])]),t._v(" "),o("ul",[o("li",[t._v("以32位操作系统举例，有4GB的虚拟内存2^22（KB）,而一页的大小为4KB（2^2KB），那么需要2^20张页表，总共占内存2^22(KB)≈4MB。")]),t._v(" "),o("li",[t._v("而"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("页表是每个进程都有分配的")])]),t._v("，如果有100个进程那么需要400MB内存来存储页表，显然"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("简单的分页在空间上有很大的牺牲")])])],1)]),t._v(" "),o("h4",{attrs:{id:"多级页表"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#多级页表"}},[t._v("#")]),t._v(" 多级页表")]),t._v(" "),o("ul",[o("li",[t._v("将上述页表分成"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("1024个页表项，每个页表项指向二级页表，每个二级页表分成1024个页表项，形成二级分页")])])],1)]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8zAL8",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zAL8.md.png",alt:"pp8zAL8.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("blockquote",[o("p",[t._v("分配一个4KB的一级页表，需要4MB的二级页表，这样是不是需要更大的空间？")])]),t._v(" "),o("ul",[o("li",[o("p",[o("font",{attrs:{color:"blue"}},[o("strong",[t._v("计算机局部性原理")])])],1),t._v(" "),o("ul",[o("li",[t._v("虽然每个进程有4GB的虚拟内存，但是在大多数情况下并没有实际用到这么多内存，存在页表项为空的情况。")]),t._v(" "),o("li",[t._v("对于已分配的页表项，在内存紧张的情况下，不常用的页表会被置换出硬盘，不会占用物理内存（此处类似于"),o("strong",[t._v("Mysql")]),t._v("的"),o("strong",[t._v("flush_lru_list")]),t._v("思想）。")])]),t._v(" "),o("blockquote",[o("p",[o("font",{attrs:{color:"#077bef"}},[t._v("如果使用到了二级分页，一级分页就可以覆盖到整个4GB虚拟内存。如果某个一级页表的页表项没有被用到，那么就没必要创建二级页表。")])],1)]),t._v(" "),o("blockquote",[o("p",[o("font",{attrs:{color:"#f96c31"}},[t._v("例如：一级页表中只有20%的页表项被用到，那么我们计算下二级页表所占用的内存大小")])],1),t._v(" "),o("p",[t._v("2^2 * 2^10 * 20% ≈ 0.08M （一级页表占用内存 * 1024个页表 * 20%使用率 ）相比于4M确实节省了许多空间")])])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("不分级的页表")]),t._v("：对于不分级的页表，从页表的职责来看，它承担的是将虚拟地址翻译成物理地址的任务，如果在虚拟地址在页表中找不到对应的页表项，那计算机就无法工作。所以不分级页表需要覆盖到所有的虚拟内存空间，也就需要"),o("strong",[t._v("100多万个页表")]),t._v("来进行映射，而二级页表只需要"),o("strong",[t._v("1024个页表项")]),t._v("（此时一级页表已经覆盖了所有的虚拟地址，二级页表只有在使用的时候才会被创建）")])]),t._v(" "),o("li",[o("p",[t._v("依次类推，当层级更高的时候，一级页表能覆盖的虚拟地址空间也会更大。")])])]),t._v(" "),o("p",[t._v("​\t"),o("font",{attrs:{color:"#077bef"}},[o("strong",[t._v("对于64位操作系统来说寻址范围有256T，")])]),t._v("显然二级分页是不够的，需要多级分页。下面将介绍64位置的四层分页")],1),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8zksf",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zksf.md.png",alt:"pp8zksf.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#077bef"}},[o("strong",[t._v("全局⻚⽬录项 PGD（Page Global Directory）；")])])],1),t._v(" "),o("li",[o("font",{attrs:{color:"#077bef"}},[o("strong",[t._v("上层⻚⽬录项 PUD（Page Upper Directory）；")])])],1),t._v(" "),o("li",[o("font",{attrs:{color:"#077bef"}},[o("strong",[t._v("中间⻚⽬录项 PMD（Page Middle Directory）；")])])],1),t._v(" "),o("li",[o("font",{attrs:{color:"#077bef"}},[o("strong",[t._v("⻚表项 PTE（Page Table Entry）；")])])],1)]),t._v(" "),o("blockquote",[o("p",[o("font",{attrs:{color:"#f96c31"}},[t._v("而层级高了以后就引发了一个新的问题：从一级页到物理页的转换需要"),o("strong",[t._v("寻址的步骤=分层数")]),t._v("，这个过程也是有性能损耗的")])],1)]),t._v(" "),o("p",[t._v("​\t因此，又来了一位朋友："),o("font",{attrs:{color:"#077bef"}},[o("strong",[t._v("页表项缓存(Cache)：TLB (Translation Lookaside Buffer)，又叫作页表缓存、转址旁路缓存、快表。")])])],1),t._v(" "),o("p",[t._v("​\tTLB存储在CPU芯片中")]),t._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#077bef"}},[o("strong",[t._v("程序局部性：")])]),t._v("从实际情况来看，程序大部分执行时间是集中在某几个代码块的，访问的内存也是在某几个区域的地址，因此CPU芯片将最常访问的那些页表项缓存在内部，缓存的页表项的通常是热点项目，命中率很高。这样便在一定程度上解决了时间的消耗。")],1)]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8zVeS",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zVeS.md.png",alt:"pp8zVeS.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("h3",{attrs:{id:"段页式内存管理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#段页式内存管理"}},[t._v("#")]),t._v(" 段页式内存管理")]),t._v(" "),o("blockquote",[o("p",[t._v("师夷长技以制夷，分段和分页的存在并不是互斥的，"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("他们之间的关系就像Redis的AOF和RDB持久化机制，各有长短，还需互补")])]),t._v("。")],1)]),t._v(" "),o("p",[t._v("(分段+分页).plus =  "),o("font",{attrs:{color:"#077bef"}},[o("strong",[t._v("段页式内存管理")])])],1),t._v(" "),o("ol",[o("li",[t._v("首先将程序划分成多个"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("逻辑段")])])],1)]),t._v(" "),o("p",[t._v("​\t"),o("a",{attrs:{href:"https://imgse.com/i/pp8zZdg",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zZdg.md.png",alt:"pp8zZdg.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[t._v("然后将每个段划分出来的"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("连续内存空间划分成固定大小的页")])])],1)]),t._v(" "),o("p",[o("a",{attrs:{href:"https://imgse.com/i/pp8zeoQ",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2023/03/17/pp8zeoQ.md.png",alt:"pp8zeoQ.md.png"}}),o("OutboundLink")],1)]),t._v(" "),o("ul",[o("li",[t._v("这样地址就由"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("段号，段内页号，页内偏移量")])]),t._v("组成，访问过程如下")],1)]),t._v(" "),o("ol",[o("li",[t._v("MMU将虚拟地址转换成段号")]),t._v(" "),o("li",[t._v("通过段号找到对应段表项中的页号")]),t._v(" "),o("li",[t._v("通过页号+页内偏移量得到物理地址")])]),t._v(" "),o("h4",{attrs:{id:"分段的内存碎片问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#分段的内存碎片问题"}},[t._v("#")]),t._v(" 分段的内存碎片问题")]),t._v(" "),o("blockquote",[o("p",[t._v("再回到内存碎片的问题")])]),t._v(" "),o("ul",[o("li",[t._v("说到底内存碎片的问题等同于提高内存利用率的问题\n对于分段产生的外部内存碎片，是由于置换操作后某一段连续的内存空间容量无法装载新的应用程序。而将产生内存的闲置浪费。")])]),t._v(" "),o("blockquote",[o("p",[t._v("分页是怎么提高内存使用率的")])]),t._v(" "),o("ul",[o("li",[t._v("而通过分页后，内存地址被进一步模块化，细化。因此能否装载新的应用程序只需要满足"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("剩余内存空间>=应用程序占用空间.")])]),t._v("。并不需要一块连续的内存空间用于装载新的程序。大大提高了内存的利用率，减少了外部的内存碎片。")],1)]),t._v(" "),o("h3",{attrs:{id:"linux的内存管理方式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#linux的内存管理方式"}},[t._v("#")]),t._v(" Linux的内存管理方式")]),t._v(" "),o("blockquote",[o("p",[o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("由于Inter X86 Cpu对程序使用的地址先进行段式映射，")])]),t._v("所以Linux避免不了使用段式")],1)]),t._v(" "),o("ul",[o("li",[o("p",[t._v("但是linux中的每个段地址都是从0开始->虚拟空间范围最大值，相当于屏蔽了段式的处理方式，每个段面对的还是整个虚拟地址。而段只被用来做访问控制和内存保护")])]),t._v(" "),o("li",[o("p",[t._v("所以从某种意义上来说Linux内存管理方式是"),o("font",{attrs:{color:"#f96c31"}},[o("strong",[t._v("页式")])]),t._v("的。")],1)])])])}),[],!1,null,null,null);r.default=s.exports}}]);